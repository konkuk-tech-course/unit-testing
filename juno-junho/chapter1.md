
# 단위테스트의 목표
1. 단위 테스트에 시간을 투자할 때는 항상 최대한 이득을 얻도록 노력해야하며,
2. 테스트에 드는 노력을 가능한 한 줄이고, 그에 따른 이득을 최대화해야 한다.
- 이 책에서 다루는 내용은 어떤 단위 테스트 기술이 좋은지를 구별하는 데 도움이 될 것이다.
- 테스트에 대한 비용 편익 분석(cost-benefit analysis) 방법을 배우고, 특정 상황에서 적절한 테스트 기술을 적용할 수 있다.
- 공통적인 안티 패턴(anti-pattern, 처음에는 괜찮은 것 같지만 미래에 문제를 야기하는 패턴)을 피하는 방법도 배운다.
- 이 장에서는 소프트웨어 산업에서 단위 테스트가 어떠한 상황에 있는지 간략히 살펴보고 테스트 작성과 유지 보수의 목표를 설명하며 테스트 스위트를 잘 작성할 수 있는 방법을 소개한다.
- 이 책은 이상적인 단위 테스트에 대해 정확하고 과학적인 정의를 다룬다.

## 1. 단위 테스트 현황
- 그냥 쓰고 버리는 프로젝트가 아니면, 단위 테스트는 늘 적용해야 한다.
- 기업용 애플리케이션 개발 프로젝트는 거의 모두 단위 테스트가 적용되어 있으며, 그 중 상당수는 수많은 `단위 테스트`와 `통합 테스트`를 통해 좋은 `코드 커버리지`를 달성하고 있다.
- 제품 코드 : 테스트 코드 비율 = 1 : 1 ~ 1 : 3 (제품코드 한 줄 : 테스트 코드 세 줄). 때로는 1 : 10 수준에 이르기도 함.
- 좋은 테스트와 좋지 않은 테스트의 차이는 취향이나 개인적인 선호도의 문제가 아니라 현재 작업중인 중대한 프로젝트의 성패를 가르는 문제이다.

## 2. 단위 테스트의 목표
- 단위 테스트의 목표는 소프트웨어 프로젝트의 **지속 가능한 성장을 가능하게 하는 것**이다. 지속 가능하다는 것이 핵심이다.
> **단위 테스트와 코드 설계의 관계**
> - 코드 조각을 단위 테스트 함으로서 비교적 높은 정확도로 저품질 코드를 가려낸다.
> - 코드를 단위 테스트 하기 어렵다면 코드 개선이 반드시 필요하다는 것을 의미한다.
> - 보통 강결합(tight coupling)에서 저품질이 나타나는데, 여기서 강결합이란 서로 충분히 제품 코드가 분리되지 않아 따로 테스트 하기 어려움을 뜻한다.
> - 코드 조각을 단위 테스트 할 수 있따는 것은 좋지 않는 긍정 지표이다.
> - 코드베이스를 쉽게 단위 테스트 할 수 있따고 해도 반드시 코드 품질이 좋은 것을 의미 하지 않는다. 낮은 결합도를 보여도 프로젝트는 '대참사'가 될 수 있다.
- 테스트는 안정망 역할을 하며, 대부분 회귀에 대한 보험을 제공하는 도구이다.
> - 회귀란 특정 사건 후에 기능이 의도한 대로 작동하지 않는 경우이다. **(소프트웨어 버그 == 회귀)** 
> - 코드베이스에서 무언가를 변경할 때마다 엔트로피(무질서도)는 증가하는데, 지속적인 정리와 리팩터링 등과 같은 적잘한 관리를 하지 않고 방치하면 시스템이 점점 더 복잡해지고 무질서해진다.
> - 하나의 버그를 수정하면 더 많은 버그를 양산하고, 도미노 같이 고장나기에 결국 코드 베이스를 신뢰할 수 없게 된다. 

- 정리하자면, **지속성과 확장성**이 핵심이다.

### 2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인
- 단위 테스트가 프로젝트 성장에 도움이 되는것은 맞지만, 테스트를 작성하는 것만으로는 충분하지 않다. 잘못 작성한 테스트는 여전히 같은 결과를 낳는다.
- 모든 테스트를 작성할 필요는 없다.
- 일부 테스트는 아주 중요하고 소프트웨어 품질에 매우 많은 기여를 한다. 그밖에 다른 테스트는 그렇지 않다.
- 단지 프로젝트에서 테스트를 더 많이 쏟아내도 단위 테스트의 목표를 달성할 수 없다. 테스트의 가치와 유지 비용을 모두 고려해야 한다.
- 지속 가능한 프로젝트 성장을 위해서는 고품질 테스트에만 집중해야 한다. 고품질 테스트만이 테스트 스위트에 남을 만한 테스트 유형이다.
> **제품코드 대 테스트 코드**
> - 코드는 자산이 아니라 책임이다.
> - 코드가 더 많아질 수록 소프트웨어 내의 잠재적인 버그에 노출되는 표면적이 더 넓어지고, 프로젝트 유지비가 증가한다.
> - 따라서 가능한 한 적은 코드로 문제를 해결하는 것이 좋다. 테스트도 역시 코드다. 코드 베이스의 일부로 봐야한다.
> - 다른 코드와 마찬가지로 단위 테스트도 버그에 취약하고 유지 보수가 필요하다.

## 3. 테스트 스위트 품질 측정을 위한 커버리지 지표
- 커버리지 숫자를 목표로 하는 것이 해로운 이유와 테스트 스위트 품질을 결정하는 데 커버리지 지표에 의존할 수 없는 이유를 알아본다.
- `커버리지 지표`는 각기 다른 유형이 있으며, 테스트 스위트의 품질을 평가하는 데 자주 사용된다.
- 일반적으로 커버리지 숫자가 높을 수록 더 좋다.
- 하지만 커버리지 지표는 중요한 피드백을 주더라도 테스트 스위트 품질을 효과적으로 측정하는 데 사용될 수 없다.
- `코드 커버리지`가 너무 적을때 (e.g 10%)는 테스트가 충분치 않다는 좋은 증거이다.
- 하지만 반대는 그렇지 못하다. 100%라 해서 반드시 양질의 테스트 스위트라고 보장하지는 않는다. 

### 3.1 코드 커버리지 지표에 대한 이해
- `코드 커버리지(테스트 커버리지)` = `제품 코드 라인 수` / `전체 라인수`
- 코드 커버리지(테스트 커버리지) 지표는 테스트 스위트가 실행한 코드 라인수 / 제품 코드베이스의 전체 라인 수의 비율로 계산한다.
</br>
코드가 작을수록 테스트 커버리지 지표는 더 좋아지는데, 이는 원래 라인 수만 처리하기 때문이다.</br> 
코드를 더 작게 해도 테스트 스위트의 가치나 기반 코드베이스의 유지 보수성이 변경되지 않는다. 

- 문제는 커버리지 숫자에 대해 얼마나 쉽게 장난 칠 수 있는지다. 
- 
### 3.2 분기 커버리지 지표에 대한 이해
- `분기 커버리지(branch coverage)`란 코드 커버리지의 단점을 극복하는데 도움이 도므로 코드 커버리지 보다 더 정확한 결과를 제공한다.
- 원시 코드 라인수를 사용하는 대신 if문과 switch 문과 같은 제어 구조에 중점을 둔다. 
- `분기 커버리지` = `통과 분기` / `전체 분기 수`
- 분기 커버리지는 지표는 분기 개수만 다루며, 해당 분기를 구현하는데 얼마나 코드가 필요한지 고려 하지 않는다. (e.g 5미만, 5보다 같거나 큰 두 가지 경우에 대해한 통과 분기를 계산하는 것으로, 코드의 길이와 상관없다.)

### 3.3 커버리지 지표에 관한 문제점
- 분기 커버리지로 코드 커버리지보다 더 나은 결과를 얻을 수 있지만, **테스트 스위트의 품질을 결정하는데 어떤 커버리지 지표도 의존할 수 없다.**
1. 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다.
   - 커버리지 지표는 기반 코드를 테스트했다고 보장할 수 없으며 일부 실행된 것만 보장한다.
2. 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.
   - 외부 라이브러리의 간단한 메서드에도 꽤 많은 경로가 존재한다. 
   - 따라서 메서드의 입력 매개변수를 변경하면 다른 결과로 이어질 수 있고, 테스트로부터 숨어있는 분기가 많기에 수많은 예외 상황(edge case)에 빠질 수 있지만, 테스트에서 모든 예외 상황을 다루는지 확인할 방법이 없다.
   - 이는 커버리지 지표가 외부 라이브러리 코드 경로를 고려해야 한다는 것이 아니라, 해당 지표로는 단위 테스트가 좋고 나쁨을 판단할 수 없다는 것을 보여준다. (고려하면 안된다.) 

### 3.4 특정 커버리지 숫자를 목표로 하기
- 커버리지 지표를 보는 가장 좋은 방법은 지표 그 자체로 보는 것이며, 목표로 여겨서는 안된다.
- 특정 커버리지 숫자를 목표로 하는 것은 단위 테스트의 목표와 반대되는 그릇된 동기 부여가 된다.
> **팁**: 시스템의 핵심 부분은 커버리지를 높게 두는 것이 좋다. 하지만 이 높은 수준을 요구 사항으로 삼는 것은 좋지 않다. 차이는 미미하지만 매우 중요하다.
- 다시 말하면, 커버리지 숫자가 낮으면 (e.g 60% 미만) 문제 징후라 할 수 있다. 그러나 넢은 숫자도 별 의미 없다.
- 코드 커버리지를 측정하는 것은 품질 테스트 스위트로 가는 첫 걸음일 뿐이다.

## 4. 무엇이 성공적인 테스트 스위트를 만드는가?
 - 그러면 테스트 스위트의 품질을 어떻게 측정해야 하는가? -> **스위트 내 각 테스트를 하나씩 따로 평가하는 것 뿐이다.**
 - 성공적인 테스트 스위트는 다음과 같은 특성을 가지고 있다.
   1. 개발 주기에 통합되어 있다.
   2. 코드베이스에서 가장 중요한 부분만을 대상으로 한다.
   3. 최소한의 유지비로 최대의 가치를 끌어낸다.

### 4.1 개발 주기에 통합돼 있음
- 자동화된 테스트를 할 수 있는 방법은 끊임없이 하는 것뿐이다.
- 모든 테스트는 개발 주기에 통합되어야 한다. 
- 이상적으로는 코드가 변경될 때마다 아무리 작은 것이라도 실행해야 한다.

### 4.2 코드베이스에서 가장 중요한 부분만을 대상으로 함
- 테스트가 주는 가치는 테스트 구조 뿐만 아니라 **검증하는 코드**에도 있다.
- 시스템의 가장 중요한 부분에 단위 테스트 노력을 기울이고, 다른 부분은 간략하게 or 간접적으로 검증하는 것이 좋다. -> **팁과 연결**
- 대부분의 애플리케이션에서 가장 중요한 부분은 비즈니스 로직(도메인 모델)이 있는 부분이다. 
- **비즈니스 로직 테스트**가 시간 투자 대비 최고의 수익을 낼 수 있다.
- 다른 모든 부분은 세 가지 범주로 나눌 수 있다.
> 1. 인프라 코드
> 2. 데이터베이스나 서드파티 시스템과 같은 외부 서비스 및 종속성
> 3. 모든 것을 하나로 묶는 코드
- 이 중 일부는 단위 테스트를 철저히 해야 할 수 있다. 예를 들어, 인프라 코드에 복잡하고 중요한 알고리즘이 있을 수 있으므로, 테스트를 많이 하는 것이 좋다.
- 통합 테스트와 같이 일부 테스트는 도메인 모델을 넘어 코드베이스의 중요하지 않은 부분을 포함해 시스템이 전체적으로 어떻게 작동하는지 확인할 수 있다. 
- **결론은, 도메인 모델을 코드베이스 중 중요하지 않은 부분과 분리해야 하며, 초점은 도메인 모델에 머물러 있어야 한다.**

### 4.3 최소 유지비로 최대 가치를 끌어냄
- **단위 테스트에서 가장 어려운 부분은 최소 유지비로 최대 가치를 달성하는 것이다. 이것이 이 책에서 말하려는 핵심이다.**
- 테스트를 빌드 시스템에 통합하는 것만으로는 충분하지 않으며, 도메인 모델에 높은 테스트 커버리지를 유지하는 것도 충분하지 않다. 
- 또한 가치가 유지비를 상회하는 테스트만 스위트에 유지하는 것이 중요하다.
- 이는 두 가지로 나뉠 수 있다.
  1. 가치있는 테스트와 가치가 낮은 테스트 식별하기
  2. 가치 있는 테스트 작성하기
- 이 가치를 구별 할 수 있는 **기준 틀**을 이 책에서 다룬다.

## 5. 이 책을 통해 배우는 것
- 이 책을 통해 테스트 스위트 내에 모든 테스트를 분석하는 데 사용할 수 있는 기준틀을 설명한다. 이 기준틀이 기초다.

### 부족한 부분
- 코드 커버리지 계산하는 법 정확히 알기